//
//  GameScene.swift
//  Malware Mind
//
//  Created by Alley Pereira on 15/03/21.
//

import Foundation
import SpriteKit
import GameplayKit

// swiftlint:disable identifier_name, line_length
enum Movements: String {
    case up = "upNode"
    case down = "downNode"
    case left = "leftNode"
    case right = "rightNode"
    case none
}

enum CollisionType: UInt32 {
    case player = 0b10
    case wall = 0b100
}

class GameScene: SKScene, SKPhysicsContactDelegate {
    
    // MARK: - Camera and SKScene related properties
    lazy var sceneCamera: SKCameraNode = {
        let camera = SKCameraNode()
        camera.setScale(2)
        return camera
    }()
    
    var viewController: GameViewController!
    var pauseViewController: PauseAlertViewController!
    
    // MARK: - Entities and Level
    var level = Level(number: 2)
    let cellWidth: Int = 35
    
    let antivirus = Antivirus()
    var previousMovement = Movements.down.rawValue
    
    var virusEntities: [VirusEntity] = []
    var collectEntities: [CollectableEntity] = []
    let background = Background()
    let hud = Hud()

    var counter = 0
    var counterStartValue = 100
    var counterTimer = Timer()
    
    let collectable1 = HudCollectableEntity()
    let collectable2 = HudCollectableEntity()
    var collectablesComponents: [CollectableComponent] = []
    
    var countLost = 0
    var countCollected = 0
    
    let startPoint = CGPoint(x: 0, y: 1)
    let endPoint = CGPoint(x: 1, y: 0)
    
    // MARK: - Control Components
    var controlComponent: PlayerControlComponent? {
        antivirus.component(ofType: PlayerControlComponent.self)
    }
    
    var collectable1Component: CollectableComponent? {
        collectable1.component(ofType: CollectableComponent.self)
    }
    
    var collectable2Component: CollectableComponent? {
        collectable2.component(ofType: CollectableComponent.self)
    }
    
    var stateMachine: GameStateMachine?
    
    var didPlayerMove = false
    var isPlaying = true
    
    private var previousUpdateTime: TimeInterval = TimeInterval()
    // MARK: - Gestures
    // MARK: - SKScene Life-Cycle

    override func didMove(to view: SKView) {
        //        self.backgroundColor = .clear
        self.physicsBody?.collisionBitMask = 2
        self.physicsBody?.categoryBitMask = 1
        self.physicsBody?.contactTestBitMask = 1

        physicsWorld.contactDelegate = self
        self.setupBackgroundGradient()
        self.setupNodesPosition()
        counter = counterStartValue
        // stateMachine?.enter(PlayState.self)
        startCounter()
        self.setupEdgeLoopAroundScene()
    }

    func setupBackgroundGradient() {
        let image: UIImage = UIImage.gradientImage(withBounds: self.frame, startPoint: startPoint, endPoint: endPoint, colors: [UIColor.gradientColor1.cgColor, UIColor.gradientColor2.cgColor])
        let gradientTexture = SKTexture(image: image)
        let gradientNode = SKSpriteNode(texture: gradientTexture)
        gradientNode.size = CGSize(width: UIScreen.main.bounds.width*2, height: UIScreen.main.bounds.height*2)
        self.addChild(gradientNode)
    }

    // MARK: - Adding Nodes to Scene
    func setupNodesPosition() {
        
        setupBackgroundNode()
        setupAntivirusNode()
        setupObstacleNodes()
        setupHudNode()
        setupCollectableNodes()
        setupVirusNodes()
        addDpadButtonNode()
        addAttackButtonNode()
        addWallNodes()
    }
    
    private func setupBackgroundNode() {
        
        guard let backgroundNode = background.tileMap else { return }

        let frame = self.frame

        if frame.height > 800 {
            backgroundNode.position = CGPoint(x: self.frame.midX, y: self.frame.midY+80)
        } else {
            backgroundNode.position = CGPoint(x: self.frame.midX, y: self.frame.midY+30)
        }

        self.addChild(backgroundNode)
    }
    
    private func setupAntivirusNode() {
        
        guard let backgroundNode = background.tileMap else { return }
        guard let antivirusSpriteNode = antivirus.component(ofType: AnimatedSpriteComponent.self)?.spriteNode else { return }
        
        antivirus.gridPosition = level.startPosition?.gridPosition
        antivirusSpriteNode.size = CGSize(width: 45, height: 60)
        antivirusSpriteNode.name = "antivirus"
        antivirusSpriteNode.makePhysicsBody(bitMask: 1, collidingWith: ContactCategory.player.rawValue, size: CGSize(width: antivirusSpriteNode.frame.width/4, height: antivirusSpriteNode.frame.height/4))
        antivirusSpriteNode.physicsBody?.restitution = 0
        var pointGrid = point(forGridPosition: antivirus.gridPosition!)
        pointGrid.y += 25
        antivirusSpriteNode.position = pointGrid

        antivirusSpriteNode.zPosition = 3

        self.addChild(antivirusSpriteNode)
        
    }
    
    private func setupObstacleNodes() {
        
        guard let backgroundNode = background.tileMap else { return }
        
        for index in 0..<level.obstaclePositions.count {
            let obstacleNode = SKSpriteNode(imageNamed: "obstacle-blue-border")
            obstacleNode.size = CGSize(width: 30, height: 30)
            obstacleNode.position = point(forGridPosition: level.obstaclePositions[index].gridPosition)
            obstacleNode.physicsBody = physicsBody
            
            addChild(obstacleNode)
        }
        
    }
    
    private func setupHudNode() {
        
        let hudTimerNode = hud.timer
        hudTimerNode.text = "\(counterStartValue)"
        let hudButtonNode = hud.pauseButton
        hudButtonNode.name = "pause"
        let colletable1Node = setCollectableNode(collectable: self.collectable1, numberCollectable: 1)
        let colletable2Node = setCollectableNode(collectable: self.collectable2, numberCollectable: 2)
        
        addChild(hudTimerNode)
        addChild(hudButtonNode)
        addChild(colletable1Node)
        addChild(colletable2Node)
        
        collectablesComponents.append(collectable1Component!)
        collectablesComponents.append(collectable2Component!)
    }
    
    private func setCollectableNode(collectable: HudCollectableEntity, numberCollectable: CGFloat) -> SKSpriteNode {
    
        guard let collectableSpriteNode = collectable.component(ofType: AnimatedSpriteComponent.self)?.spriteNode else { return SKSpriteNode() }
        
        collectableSpriteNode.size = CGSize(width: 25, height: 29.5)
        collectableSpriteNode.setScale(1.2)
        collectableSpriteNode.position = CGPoint(x: UIScreen.main.bounds.minX+((collectableSpriteNode.frame.width+15)*numberCollectable), y: UIScreen.main.bounds.maxY * 0.913)
        
        return collectableSpriteNode
    }
    
    func setColletableLost() {
        
        collectablesComponents.first?.handle(state: .lost)
    }
    
    func setColletableCollected() {
        
        collectablesComponents.first?.handle(state: .collected)
    }
    
    private func setupCollectableNodes() {
        
        for index in 0..<level.collectablePositions.count {
            let collectEntity = CollectableEntity()
            
            guard let collectableSpriteComponent = collectEntity.component(ofType: AnimatedSpriteComponent.self)?.spriteNode else { return }
            collectableSpriteComponent.name = "collectable\(index)"
            
            let physicsBody = SKPhysicsBody(circleOfRadius: CGFloat(cellWidth/4))
            physicsBody.categoryBitMask = ContactCategory.collect.rawValue
            physicsBody.contactTestBitMask = ContactCategory.enemy.rawValue | ContactCategory.player.rawValue
            physicsBody.affectedByGravity = false
            physicsBody.allowsRotation = false
            physicsBody.collisionBitMask = 0
            
            collectEntity.gridPosition = level.collectablePositions[index].gridPosition
            collectableSpriteComponent.position = point(forGridPosition: collectEntity.gridPosition!)
            collectableSpriteComponent.owner = collectEntity.component(ofType: AnimatedSpriteComponent.self)
            collectableSpriteComponent.setScale(0.25)
            collectableSpriteComponent.physicsBody = physicsBody
            collectableSpriteComponent.size = CGSize(width: 30, height: 30)
            self.addChild(collectableSpriteComponent)
            
            collectEntities.append(collectEntity)
        }
        
    }
    
    private func setupVirusNodes() {
        
        for index in 0..<level.enemyStartPositions.count {
            let virusEntity = VirusEntity()
            
            virusEntity.addComponent(VirusControlComponent(game: self, enemy: virusEntity, goal: collectEntities, startingPosition: level.enemyStartPositions[index]))
            guard let virusSpriteComponent = virusEntity.component(ofType: AnimatedSpriteComponent.self)?.spriteNode else { return }
            
            let physicsBody = SKPhysicsBody(circleOfRadius: CGFloat(cellWidth))
            physicsBody.categoryBitMask = ContactCategory.enemy.rawValue
            physicsBody.contactTestBitMask = ContactCategory.collect.rawValue | ContactCategory.player.rawValue
            physicsBody.affectedByGravity = false
            physicsBody.allowsRotation = false
            physicsBody.collisionBitMask = 0
            
            if let virusPosition = virusEntity.gridPosition {
                virusSpriteComponent.position = point(forGridPosition: virusPosition)
            }
            virusSpriteComponent.owner = virusEntity.component(ofType: AnimatedSpriteComponent.self)
            virusSpriteComponent.physicsBody = physicsBody
            virusSpriteComponent.setScale(0.25)
            
            self.addChild(virusSpriteComponent)
            
            virusEntities.append(virusEntity)
        }
    }

    private func addDpadButtonNode() {
        
        guard let backgroundNode = background.tileMap else { return }
        
        let dPadButton = SKSpriteNode(imageNamed: "dpadButton")
        dPadButton.size = CGSize(width: UIScreen.main.bounds.width*0.30, height: UIScreen.main.bounds.width*0.29)

        let frame = self.frame

        if frame.height > 800 {
            dPadButton.position = CGPoint(x: UIScreen.main.bounds.midX*0.5, y: backgroundNode.frame.minY-(dPadButton.frame.height+40))
        } else {
            dPadButton.position = CGPoint(x: UIScreen.main.bounds.midX*0.5, y: backgroundNode.frame.minY-(dPadButton.frame.height))
        }

        addChild(dPadButton)

        let upNode = setupDpadButtonsNode(named: "upNode", imageNamed: "up", position: CGPoint(x: dPadButton.frame.midX, y: dPadButton.frame.maxY-15))
        let downNode = setupDpadButtonsNode(named: "downNode", imageNamed: "down", position: CGPoint(x: dPadButton.frame.midX, y: dPadButton.frame.minY+15))
        let leftNode = setupDpadButtonsNode(named: "leftNode", imageNamed: "left", position: CGPoint(x: dPadButton.frame.minX+15, y: dPadButton.frame.midY))
        let rightNode = setupDpadButtonsNode(named: "rightNode", imageNamed: "right", position: CGPoint(x: dPadButton.frame.maxX-15, y: dPadButton.frame.midY))
        
        addChild(upNode)
        addChild(downNode)
        addChild(rightNode)
        addChild(leftNode)
    }
    
    private func setupDpadButtonsNode(named: String, imageNamed: String, position: CGPoint) -> SKSpriteNode {
        
        let node = SKSpriteNode(imageNamed: imageNamed)
        
        node.name = named
        node.size = CGSize(width: UIScreen.main.bounds.width*0.058, height: UIScreen.main.bounds.width*0.054)
        node.position = position
        
        return node
    }
    
    private func addAttackButtonNode() {
        
        guard let backgroundNode = background.tileMap else { return }
        
        let attackButton = SKSpriteNode(imageNamed: "attackButton")
        attackButton.size = CGSize(width: UIScreen.main.bounds.width*0.23, height: UIScreen.main.bounds.width*0.22)

        let frame = self.frame

        if frame.height > 800 {
            attackButton.position = CGPoint(x: UIScreen.main.bounds.midX*1.5, y: backgroundNode.frame.minY-(attackButton.frame.height+70))
        } else {
            attackButton.position = CGPoint(x: UIScreen.main.bounds.midX*1.5, y: backgroundNode.frame.minY-(attackButton.frame.height+20))
        }

        attackButton.name = "attackNode"
        addChild(attackButton)
        
    }
    
    private func addWallNodes() {
        
        guard let backgroundNode = background.tileMap else { return }

        let topWallNode = setupWall(named: "topWall", imageNamed: "top_Wall", size: CGSize(width: backgroundNode.mapSize.width+60, height: 25), position: CGPoint(x: backgroundNode.frame.midX, y: backgroundNode.frame.maxY+10))
        
        let bottomWallNode = setupWall(named: "bottomWall", imageNamed: "bottom_Wall", size: CGSize(width: backgroundNode.mapSize.width+60, height: 25), position: CGPoint(x: backgroundNode.frame.midX, y: backgroundNode.frame.minY-10))
        
        let leftWallNode = setupWall(named: "leftWall", imageNamed: "left_Wall", size: CGSize(width: 31, height: backgroundNode.mapSize.height+20), position: CGPoint(x: backgroundNode.frame.minX-14.5, y: backgroundNode.frame.midY-5))
        
        let rightWallNode = setupWall(named: "rightWall", imageNamed: "right_Wall", size: CGSize(width: 31, height: backgroundNode.mapSize.height+20), position: CGPoint(x: backgroundNode.frame.maxX+14.5, y: backgroundNode.frame.midY+5))

        addChild(leftWallNode)
        addChild(rightWallNode)
        addChild(topWallNode)
        addChild(bottomWallNode)
        
    }
    
    private func setupWall(named: String, imageNamed: String, size: CGSize, position: CGPoint) -> SKSpriteNode {
        
        let node = SKSpriteNode(imageNamed: imageNamed)
        
        node.name = named
        node.size = size
        node.position = position
        
        return node
    }

    private func setupEdgeLoopAroundScene() {
        let levelEdgeLoop = CGRect(
            x: background.tileMap.frame.minX - 5,
            y: background.tileMap.frame.minY + 12,
            width: background.tileMap.frame.width + 10,
            height: background.tileMap.frame.height + 6)
        self.physicsBody = SKPhysicsBody(edgeLoopFrom: levelEdgeLoop)
    }

    func didBegin(_ contact: SKPhysicsContact) {
        print("to tocando")
        // print(contact.contactPoint)
                
        guard let bodyASpriteNode = contact.bodyA.node! as? SpriteNode,
              let bodyBSpriteNode = contact.bodyB.node! as? SpriteNode else { return }
        
        let enemyIsBodyA: Bool = contact.bodyA.categoryBitMask == ContactCategory.enemy.rawValue
        let enemyIsBodyB: Bool = contact.bodyB.categoryBitMask == ContactCategory.enemy.rawValue
        
        let collectableIsBodyA: Bool = contact.bodyA.categoryBitMask == ContactCategory.collect.rawValue
        let collectableIsBodyB: Bool = contact.bodyB.categoryBitMask == ContactCategory.collect.rawValue
        
        let playerIsBodyA: Bool = contact.bodyA.categoryBitMask == ContactCategory.player.rawValue
        let playerIsBodyB: Bool = contact.bodyB.categoryBitMask == ContactCategory.player.rawValue

        var enemyNode: SpriteNode!
        if enemyIsBodyA {
            enemyNode = bodyASpriteNode
        } else if enemyIsBodyB {
            enemyNode = bodyBSpriteNode
        }
        
        var collectableNode: SpriteNode!
        if collectableIsBodyA {
            collectableNode = bodyASpriteNode
        } else if collectableIsBodyB {
            collectableNode = bodyBSpriteNode
        }
        
        var playerNode: SpriteNode!
        if playerIsBodyA {
            playerNode = bodyASpriteNode
        } else if playerIsBodyB {
            playerNode = bodyBSpriteNode
        }
        
        if enemyNode != nil, let collectable = collectableNode {
            countLost += 1
            let castCollectable = collectable.owner?.entity as? CollectableEntity
            let collectableSprite = castCollectable?.component(ofType: AnimatedSpriteComponent.self)?.spriteNode
            
            setColletableLost()
            collectablesComponents.removeFirst()
            
            if countLost == 2 {
                stateMachine?.enter(GameOverState.self)
            }
            
            removeChildren(in: [collectableSprite!])
            
            for index in 0..<collectEntities.count where castCollectable!.gridPosition == collectEntities[index].gridPosition {
                collectEntities.remove(at: index)
                break
            }
            
            for index in 0..<virusEntities.count {
                virusEntities[index].component(ofType: VirusControlComponent.self)?.updateWalkState(new: collectEntities)
            }
        } else if playerNode != nil, let collectable = collectableNode {
            countCollected += 1
            let castCollectable = collectable.owner?.entity as? CollectableEntity
            let collectableSprite = castCollectable?.component(ofType: AnimatedSpriteComponent.self)?.spriteNode
            
            setColletableCollected()
            collectablesComponents.removeFirst()
            
            if countCollected == 2 {
                stateMachine?.enter(GameWonState.self)
            }
            
            removeChildren(in: [collectableSprite!])
            
            for index in 0..<collectEntities.count where castCollectable!.gridPosition == collectEntities[index].gridPosition {
                collectEntities.remove(at: index)
                break
            }
            
            for index in 0..<virusEntities.count {
                virusEntities[index].component(ofType: VirusControlComponent.self)?.updateWalkState(new: collectEntities)
            }
        } else if playerNode != nil, enemyNode != nil {
            stateMachine?.enter(GameOverState.self)
            counterTimer.invalidate()
        }

    }

    func startCounter() {
        counterTimer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(decrementCounter), userInfo: nil, repeats: true)
    }
    
    func point(forGridPosition position: SIMD2<Int32>) -> CGPoint {
        return CGPoint(
            x: Int(position.x) * cellWidth + 102,
            y: Int(position.y) * cellWidth * -1 + 705
        )
    }

    @objc func decrementCounter() {
        
        // guard isPlaying else { return }
        if isPlaying {
            if counter > 0 {
                counter -= 1
                hud.timer.text = "\(counter)"
            } else if counter == 0 {
                stateMachine?.enter(GameOverState.self)
                counterTimer.invalidate()
            }
        }
    }
    
    private var prevUpdateTime: TimeInterval = 0.0
    
    override func update(_ currentTime: TimeInterval) {
        super.update(currentTime)

        // Track remaining time delta since last update.
        if self.prevUpdateTime == 0 {
            self.prevUpdateTime = currentTime
        }

        let delta = currentTime - self.prevUpdateTime
        self.prevUpdateTime = currentTime

        if didPlayerMove {
            // Update components with the new time delta.
            for index in 0..<virusEntities.count {
                self.virusEntities[index].update(deltaTime: delta)
            }
            
            didPlayerMove = false
        }
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {

        guard let touch = touches.first else { return }
        let location = touch.location(in: self)
        let tappedNodes = nodes(at: location)

        for node in tappedNodes {
            switch node.name {
            case Movements.up.rawValue:
                if checkPlayerMovement(for: node.name) {
                    controlComponent?.handle(direction: .up)
                    antivirus.gridPosition?.y -= 1
                    previousMovement = node.name!
                }
            case Movements.down.rawValue:
                if checkPlayerMovement(for: node.name) {
                    controlComponent?.handle(direction: .down)
                    antivirus.gridPosition?.y += 1
                    previousMovement = node.name!
                }
            case Movements.left.rawValue:
                if checkPlayerMovement(for: node.name) {
                    controlComponent?.handle(direction: .left)
                    antivirus.gridPosition?.x -= 1
                    previousMovement = node.name!
                }
            case Movements.right.rawValue:
                if checkPlayerMovement(for: node.name) {
                    controlComponent?.handle(direction: .right)
                    antivirus.gridPosition?.x += 1
                    previousMovement = node.name!
                }
            case "attackNode":
                print("attacking you")
                checkPlayerAttack()
                guard let animationDirection = Movements(rawValue: previousMovement) else { return }
                controlComponent?.handleAnimation(direction: animationDirection)
                didPlayerMove = true
            case "wall":
                print("hitting the wall")
            case "pause":
                // counterTimer.invalidate()
                stateMachine?.enter(PausedState.self)
                isPlaying = false
                // NotificationCenter.default.post(name: NSNotification.Name(rawValue: "pauseGameID"), object: nil)
            default:
                print("none")
            }
        }
    }
    
    func checkPlayerMovement(for direction: String?) -> Bool {
        switch direction {
        case Movements.up.rawValue:
            var checkedPosition = antivirus.gridPosition
            checkedPosition?.y -= 1
            for index in 0..<level.obstaclePositions.count where level.obstaclePositions[index].gridPosition == checkedPosition {
                return false
            }
            didPlayerMove = true
            return true
        case Movements.down.rawValue:
            var checkedPosition = antivirus.gridPosition
            checkedPosition?.y += 1
            for index in 0..<level.obstaclePositions.count where level.obstaclePositions[index].gridPosition == checkedPosition {
                return false
            }
            didPlayerMove = true
            return true
        case Movements.left.rawValue:
            var checkedPosition = antivirus.gridPosition
            checkedPosition?.x -= 1
            for index in 0..<level.obstaclePositions.count where level.obstaclePositions[index].gridPosition == checkedPosition {
                return false
            }
            didPlayerMove = true
            return true
        case Movements.right.rawValue:
            var checkedPosition = antivirus.gridPosition
            checkedPosition?.x += 1
            for index in 0..<level.obstaclePositions.count where level.obstaclePositions[index].gridPosition == checkedPosition {
                return false
            }
            didPlayerMove = true
            return true
        default:
            print("No movement")
            return false
        }
    }
    
    func checkPlayerAttack() {
        switch previousMovement {
        case Movements.up.rawValue:
            var checkedPosition = antivirus.gridPosition
            checkedPosition?.y -= 1
            for index in 0..<virusEntities.count where virusEntities[index].gridPosition == checkedPosition {
                    let virusSprite = virusEntities[index].component(ofType: AnimatedSpriteComponent.self)?.spriteNode
                    removeChildren(in: [virusSprite!])
                    virusEntities.remove(at: index)
                    break
            }
        case Movements.down.rawValue:
            var checkedPosition = antivirus.gridPosition
            checkedPosition?.y += 1
            for index in 0..<virusEntities.count where virusEntities[index].gridPosition == checkedPosition {
                    let virusSprite = virusEntities[index].component(ofType: AnimatedSpriteComponent.self)?.spriteNode
                    removeChildren(in: [virusSprite!])
                    virusEntities.remove(at: index)
                    break
            }
        case Movements.left.rawValue:
            var checkedPosition = antivirus.gridPosition
            checkedPosition?.x -= 1
            for index in 0..<virusEntities.count where virusEntities[index].gridPosition == checkedPosition {
                    let virusSprite = virusEntities[index].component(ofType: AnimatedSpriteComponent.self)?.spriteNode
                    removeChildren(in: [virusSprite!])
                    virusEntities.remove(at: index)
                    break
            }
        case Movements.right.rawValue:
            var checkedPosition = antivirus.gridPosition
            checkedPosition?.x += 1
            for index in 0..<virusEntities.count where virusEntities[index].gridPosition == checkedPosition {
                    let virusSprite = virusEntities[index].component(ofType: AnimatedSpriteComponent.self)?.spriteNode
                    removeChildren(in: [virusSprite!])
                    virusEntities.remove(at: index)
                    break
            }
        default:
            print("No attack")
        }
    }
}

extension SKSpriteNode {

    func makePhysicsBody(bitMask: UInt32, collidingWith collision: UInt32, size: CGSize) {
        let physicsBody = SKPhysicsBody(rectangleOf: size)

            physicsBody.collisionBitMask = bitMask
            physicsBody.contactTestBitMask = collision
            physicsBody.categoryBitMask = collision

            physicsBody.affectedByGravity = false
            physicsBody.allowsRotation = false

            self.physicsBody = physicsBody
        }
}
